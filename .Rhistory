(lt.addChrTz = as.POSIXlt(paste0(off_data_time_pa, " UTC"))) %>% unname()
paste0(off_data_time_pa, " UTC")
(lt.addChrTz = as.POSIXlt(paste0(off_data_time_pa, " UTC"),usetz=T)) %>% unname()
Sys.timezone()
with_tz(as.POSIXct(off_data_time_pa,tz="America/New_York",usetz=T), tzone='UTC') %>% unname()
with_tz(as.POSIXlt(off_data_time_pa,tz="America/New_York",usetz=T), tzone='UTC') %>% unname()
(time_list_pa = as.POSIXlt(format(off_data_time_pa,tz="America/New_York",usetz=TRUE))) %>% unname()
(time_list_pa = as.POSIXlt(=off_data_time_pa,tz="America/New_York",usetz=TRUE)) %>% unname()
(time_list_pa = as.POSIXlt(off_data_time_pa,tz="America/New_York",usetz=TRUE)) %>% unname()
t = c(time_list_pa[1], "2004-05-05", "2004-06-29 10:51:00", time_list_pa[4:10])
warning("Please make sure that the input time has the correct time zone. ")
stopifnot("Please input t as POSIXlt format. \n
Time data can be converted to POSIXlt with as.POSIXlt(). Notice that Sys.timezone() will be used if you did not specify correct tz in as.POSIXlt(). " =
sum(class(t)=="POSIXlt")>0)
stopifnot("lat and long should both be vectors" = is.vector(lat)&is.vector(long))
stopifnot("Please make sure that t, lat, and long are of the same lengths" = length(t)==length(lat)&length(t)==length(long))
date.time.flag = 0
lat
SunRiseTime = function(d,Lat,Long){
## d is the day of year
## Lat is latitude in decimal degrees
## Long is longitude in decimal degrees (negative == West)
##This method is copied from:
##Teets, D.A. 2003. Predicting sunrise and sunset times.
##  The College Mathematics Journal 34(4):317-321.
## At the default location the estimates of sunrise and sunset are within
## seven minutes of the correct times (http://aa.usno.navy.mil/data/docs/RS_OneYear.php)
## with a mean of 2.4 minutes error.
## Function to convert degrees to radians
rad<-function(x)pi*x/180
##Radius of the earth (km)
R=6378
##Radians between the xy-plane and the ecliptic plane
epsilon=rad(23.45)
##Convert observer's latitude to radians
L=rad(Lat)
## Calculate offset of sunrise based on longitude (min)
## If Long is negative, then the mod represents degrees West of
## a standard time meridian, so timing of sunrise and sunset should
## be made later.
timezone = -4*(abs(Long)%%15)*sign(Long)
## The earth's mean distance from the sun (km)
r = 149598000
theta = 2*pi/365.25*(d-80)
z.s = r*sin(theta)*sin(epsilon)
r.p = sqrt(r^2-z.s^2)
t0 = 1440/(2*pi)*acos((R-z.s*sin(L))/(r.p*cos(L)))
##a kludge adjustment for the radius of the sun
that = t0+5
## Adjust "noon" for the fact that the earth's orbit is not circular:
n = 720-10*sin(4*pi*(d-80)/365.25)+8*sin(2*pi*d/365.25)
## now sunrise and sunset are:
sunrise = (n-that+timezone)/60
sunset = (n+that+timezone)/60
return(list("sunrise" = sunrise,"sunset" = sunset, "timezone" = timezone))
}
#calculate sunrise time
day = t$yday
day = t$yday
prev_sunrise<- suncalc(day-1, Lat = lat, Long = long, UTC = F)$sunrise
cur_sunrise <- suncalc(day, Lat = lat, Long = long, UTC = F)$sunrise
next_sunrise <- suncalc(day+1, Lat = lat, Long = long, UTC = F)$sunrise
prev_sunrise
cur_sunrise
next_sunrise
t
i = 2
a.t = t[i]
strptime(a.t, format="%Y-%m-%d %H:%M:%S")
for(i in 1:length(t)){
a.t = t[i]
if(is.na(strptime(a.t, format="%Y-%m-%d %H:%M:%S"))){
date.time.flag = 1
print(paste0(i, "NA"))
}
}
t_chr = as.character(t)
t_chr
t
t_UTC = lubridate::with_tz(t, tzone='UTC')
t_UTC
t
suncalc(day-1, Lat = lat, Long = long)
SunRiseTime = function(d,Lat,Long){
## d is the day of year
## Lat is latitude in decimal degrees
## Long is longitude in decimal degrees (negative == West)
##This method is copied from:
##Teets, D.A. 2003. Predicting sunrise and sunset times.
##  The College Mathematics Journal 34(4):317-321.
## At the default location the estimates of sunrise and sunset are within
## seven minutes of the correct times (http://aa.usno.navy.mil/data/docs/RS_OneYear.php)
## with a mean of 2.4 minutes error.
## Function to convert degrees to radians
rad<-function(x)pi*x/180
##Radius of the earth (km)
R=6378
##Radians between the xy-plane and the ecliptic plane
epsilon=rad(23.45)
##Convert observer's latitude to radians
L=rad(Lat)
## Calculate offset of sunrise based on longitude (min)
## If Long is negative, then the mod represents degrees West of
## a standard time meridian, so timing of sunrise and sunset should
## be made later.
timezone = -4*(abs(Long)%%15)*sign(Long)
## The earth's mean distance from the sun (km)
r = 149598000
theta = 2*pi/365.25*(d-80)
z.s = r*sin(theta)*sin(epsilon)
r.p = sqrt(r^2-z.s^2)
t0 = 1440/(2*pi)*acos((R-z.s*sin(L))/(r.p*cos(L)))
##a kludge adjustment for the radius of the sun
that = t0+5
## Adjust "noon" for the fact that the earth's orbit is not circular:
n = 720-10*sin(4*pi*(d-80)/365.25)+8*sin(2*pi*d/365.25)
## now sunrise and sunset are:
sunrise = (n-that+timezone)/60
sunset = (n+that+timezone)/60
return(list("sunrise" = sunrise,"sunset" = sunset, "timezone" = timezone))
}
prev_sunrise<- SunRiseTime(day-1, Lat = lat, Long = long)
cur_sunrise <- SunRiseTime(day, Lat = lat, Long = long)
next_sunrise <- SunRiseTime(day+1, Lat = lat, Long = long)
prev_sunrise
cur_sunrise
60*98356
60*0.98356
a.t
i
time_diff_pa
prev_sunrise$timezone
time_diff_pa<- rep(0,length(time_list_pa))
for (i in 1:length(time_list_pa)){
if ( grepl('EDT',time_list_pa[i]$zone)) {
time_diff_pa[i] <- (UTC_time_pa[i]$hour + 1*(UTC_time_pa[i]$min/60) + 1 )-
(time_list_pa[i]$hour+1*(time_list_pa[i]$min/60) )
} else
time_diff_pa[i] <- (UTC_time_pa[i]$hour + 1*(UTC_time_pa[i]$min/60))-
(time_list_pa[i]$hour+1*(time_list_pa[i]$min/60) )
}
time_diff_pa
time_list_pa
i = 1
UTC_time_pa[i]$hour
UTC_time_pa[i]$hour + 1*(UTC_time_pa[i]$min/60)
UTC_time_pa[i]$hour
time_list_pa[i]$hour
i = 2
UTC_time_pa[i]$hour
time_list_pa[i]$hour
prev_sunrise$timezone/60
cur_sunrise
360/15
long
long%%15
long/15
15
79/15
5*15
abs(long%%15)
abs(long)
abs(long)%%15
abs(long)-15*5
abs(Long)%/%15
abs(long)%/%15
SunRiseTime = function(d,Lat,Long){
## d is the day of year
## Lat is latitude in decimal degrees
## Long is longitude in decimal degrees (negative == West)
##This method is copied from:
##Teets, D.A. 2003. Predicting sunrise and sunset times.
##  The College Mathematics Journal 34(4):317-321.
## At the default location the estimates of sunrise and sunset are within
## seven minutes of the correct times (http://aa.usno.navy.mil/data/docs/RS_OneYear.php)
## with a mean of 2.4 minutes error.
## Function to convert degrees to radians
rad<-function(x)pi*x/180
##Radius of the earth (km)
R=6378
##Radians between the xy-plane and the ecliptic plane
epsilon=rad(23.45)
##Convert observer's latitude to radians
L=rad(Lat)
## Calculate offset of sunrise based on longitude (min)
## If Long is negative, then the mod represents degrees West of
## a standard time meridian, so timing of sunrise and sunset should
## be made later.
timezone = -4*(abs(Long)%%15)*sign(Long)
timezone2 = abs(Long)%/%15*sign(Long)
## The earth's mean distance from the sun (km)
r = 149598000
theta = 2*pi/365.25*(d-80)
z.s = r*sin(theta)*sin(epsilon)
r.p = sqrt(r^2-z.s^2)
t0 = 1440/(2*pi)*acos((R-z.s*sin(L))/(r.p*cos(L)))
##a kludge adjustment for the radius of the sun
that = t0+5
## Adjust "noon" for the fact that the earth's orbit is not circular:
n = 720-10*sin(4*pi*(d-80)/365.25)+8*sin(2*pi*d/365.25)
## now sunrise and sunset are:
sunrise = (n-that+timezone)/60
sunset = (n+that+timezone)/60
return(list("sunrise" = sunrise,"sunset" = sunset, "timezone" = timezone2))
}
prev_sunrise_pa <- suncalc(day_pa-1, Lat = Lat_pa, Long = Long_pa, UTC = F)$sunrise
cur_sunrise_pa <- suncalc(day_pa, Lat = Lat_pa, Long = Long_pa, UTC = F)$sunrise
next_sunrise_pa <- suncalc(day_pa+1, Lat = Lat_pa, Long = Long_pa, UTC = F)$sunrise
cur_sunrise_pa
prev_sunrise<- SunRiseTime(day-1, Lat = lat, Long = long)
cur_sunrise <- SunRiseTime(day, Lat = lat, Long = long)
next_sunrise <- SunRiseTime(day+1, Lat = lat, Long = long)
cur_sunrise
prev_sunrise
next_sunrise
time_diff_pa
t_UTC
t_UTC %>% unname()
t %>% unname()
cur_sunrise
i
i = 1
t_UTC[i]-cur_sunrise[i]$sunrise+cur_sunrise[i]$timezone>=-6
t_UTC[i]
t_UTC_num = t_UTC$hour + t_UTC$min/60
t_UTC_num[i]-cur_sunrise[i]$sunrise+cur_sunrise[i]$timezone
t_UTC_num[i]
cur_sunrise[i]$sunrise
cur_sunrise
t_UTC_num[i]-cur_sunrise$sunrise[i]
cur_sunrise$timezone[i]
t_UTC
t_UTC %>% unname()
t %>% unname()
t_UTC_num[i]+cur_sunrise$timezone[i]
t_num = t$hour+t$min/60
t_num
t_UTC_num[i]+cur_sunrise$timezone[i]-cur_sunrise$sunrise[i]
date.time.flag = 0
corrected.time = vector()
for(i in 1:length(t)){
a.t = t[i]
if(t_UTC_num[i]+cur_sunrise$timezone[i]-cur_sunrise$sunrise[i]>=ZT.min){
corrected.time[i]<- t_UTC_num[i]+cur_sunrise$timezone[i]-cur_sunrise$sunrise[i]
} else {
corrected.time[i] <- t_UTC_num[i]+prev_sunrise$timezone[i] + (24 - prev_sunrise$sunrise[i])
}
if(is.na(strptime(a.t, format="%Y-%m-%d %H:%M:%S"))){
date.time.flag = 1
corrected.time[i] = NA
}
}
ZT.min = -6
date.time.flag = 0
corrected.time = vector()
for(i in 1:length(t)){
a.t = t[i]
if(t_UTC_num[i]+cur_sunrise$timezone[i]-cur_sunrise$sunrise[i]>=ZT.min){
corrected.time[i]<- t_UTC_num[i]+cur_sunrise$timezone[i]-cur_sunrise$sunrise[i]
} else {
corrected.time[i] <- t_UTC_num[i]+prev_sunrise$timezone[i] + (24 - prev_sunrise$sunrise[i])
}
if(is.na(strptime(a.t, format="%Y-%m-%d %H:%M:%S"))){
date.time.flag = 1
corrected.time[i] = NA
}
}
corrected.time
tod_pa
t_UTC_num
t_num
t_UTC_num-t_num
CorrectTime = function(t, lat, long, ZT.min = 0)
CorrectTime(t, lat, long, ZT.min = 0)
CorrectTime = function(t, lat, long, ZT.min = -6){
warning("Please make sure that the input time has the correct time zone. ")
#check if input is POSIXlt
stopifnot("Please input t as POSIXlt format. \n
Time data can be converted to POSIXlt with as.POSIXlt(). Notice that Sys.timezone() will be used if you did not specify correct tz in as.POSIXlt(). " =
sum(class(t)=="POSIXlt")>0)
stopifnot("lat and long should both be vectors" = is.vector(lat)&is.vector(long))
stopifnot("Please make sure that t, lat, and long are of the same lengths" = length(t)==length(lat)&length(t)==length(long))
#calculate sunrise time
day = t$yday
prev_sunrise<- SunRiseTime(day-1, Lat = lat, Long = long)
cur_sunrise <- SunRiseTime(day, Lat = lat, Long = long)
next_sunrise <- SunRiseTime(day+1, Lat = lat, Long = long)
t_chr = as.character(t)
t_UTC = lubridate::with_tz(t, tzone='UTC') #convert time to UTZ
t_UTC_num = t_UTC$hour + t_UTC$min/60
t_num = t$hour+t$min/60
date.time.flag = 0
corrected.time = vector()
for(i in 1:length(t)){
a.t = t[i]
if(t_UTC_num[i]+cur_sunrise$timezone[i]-cur_sunrise$sunrise[i]>=ZT.min){
corrected.time[i]<- t_UTC_num[i]+cur_sunrise$timezone[i]-cur_sunrise$sunrise[i]
} else {
corrected.time[i] <- t_UTC_num[i]+prev_sunrise$timezone[i] + (24 - prev_sunrise$sunrise[i])
}
#check if t contains both date and time
if(is.na(strptime(a.t, format="%Y-%m-%d %H:%M:%S"))){
date.time.flag = 1
corrected.time[i] = NA
}
}
if(date.time.flag){
warning("t without time (HH:MM:SS) input will be set to NA. ")
}
return(corrected.time)
}
CorrectTime(t, lat, long, ZT.min = 0)
CorrectTime(t, lat, long, ZT.min = -6)
-5.443038 +24
CorrectTime = function(t, lat, long, ZT.min = -6){
warning("Please make sure that the input time has the correct time zone. ")
#check if input is POSIXlt
stopifnot("Please input t as POSIXlt format. \n
Time data can be converted to POSIXlt with as.POSIXlt(). Notice that Sys.timezone() will be used if you did not specify correct tz in as.POSIXlt(). " =
sum(class(t)=="POSIXlt")>0)
stopifnot("lat and long should both be vectors" = is.vector(lat)&is.vector(long))
stopifnot("Please make sure that t, lat, and long are of the same lengths" = length(t)==length(lat)&length(t)==length(long))
#calculate sunrise time
day = t$yday
prev_sunrise<- SunRiseTime(day-1, Lat = lat, Long = long)
cur_sunrise <- SunRiseTime(day, Lat = lat, Long = long)
next_sunrise <- SunRiseTime(day+1, Lat = lat, Long = long)
t_chr = as.character(t)
t_UTC = lubridate::with_tz(t, tzone='UTC') #convert time to UTZ
t_UTC_num = t_UTC$hour + t_UTC$min/60
# t_num = t$hour+t$min/60
ZT.max = ZT.min+24
date.time.flag = 0
corrected.time = vector()
for(i in 1:length(t)){
a.t = t[i]
if(t_UTC_num[i]+cur_sunrise$timezone[i]-cur_sunrise$sunrise[i]>=0){
corrected.time[i]<- t_UTC_num[i]+cur_sunrise$timezone[i]-cur_sunrise$sunrise[i]
} else {
corrected.time[i] <- t_UTC_num[i]+prev_sunrise$timezone[i] + (24 - prev_sunrise$sunrise[i])
}
corrected.time[i] = ifelse(corrected.time[i]>ZT.max, corrected.time[i]-24,
ifelse(corrected.time[i]<ZT.min), corrected.time[i]+24, corrected.time[i])
#check if t contains both date and time
if(is.na(strptime(a.t, format="%Y-%m-%d %H:%M:%S"))){
date.time.flag = 1
corrected.time[i] = NA
}
}
if(date.time.flag){
warning("t without time (HH:MM:SS) input will be set to NA. ")
}
return(corrected.time)
}
t
t = as.POSIXlt("2022-09-17 13:43:00 EST", tz="America/New_York",usetz=TRUE)
lat = 40.4406; long = -79.9959
CorrectTime(t, lat, long, ZT.min = -6)
t
CorrectTime = function(t, lat, long, ZT.min = -6){
warning("Please make sure that the input time has the correct time zone. ")
#check if input is POSIXlt
stopifnot("Please input t as POSIXlt format. \n
Time data can be converted to POSIXlt with as.POSIXlt(). Notice that Sys.timezone() will be used if you did not specify correct tz in as.POSIXlt(). " =
sum(class(t)=="POSIXlt")>0)
stopifnot("lat and long should both be vectors" = is.vector(lat)&is.vector(long))
stopifnot("Please make sure that t, lat, and long are of the same lengths" = length(t)==length(lat)&length(t)==length(long))
#calculate sunrise time
day = t$yday
prev_sunrise<- SunRiseTime(day-1, Lat = lat, Long = long)
cur_sunrise <- SunRiseTime(day, Lat = lat, Long = long)
next_sunrise <- SunRiseTime(day+1, Lat = lat, Long = long)
t_chr = as.character(t)
t_UTC = lubridate::with_tz(t, tzone='UTC') #convert time to UTZ
t_UTC_num = t_UTC$hour + t_UTC$min/60
# t_num = t$hour+t$min/60
ZT.max = ZT.min+24
date.time.flag = 0
corrected.time = vector()
for(i in 1:length(t)){
a.t = t[i]
if(t_UTC_num[i]+cur_sunrise$timezone[i]-cur_sunrise$sunrise[i]>=0){
corrected.time[i]<- t_UTC_num[i]+cur_sunrise$timezone[i]-cur_sunrise$sunrise[i]
} else {
corrected.time[i] <- t_UTC_num[i]+prev_sunrise$timezone[i] + (24 - prev_sunrise$sunrise[i])
}
#transform the time into (ZT.min, ZT.max)
ifelse(corrected.time[i]>ZT.max, corrected.time[i]-24,
ifelse(corrected.time[i]<ZT.min), corrected.time[i]+24, corrected.time[i])
#check if t contains both date and time
if(is.na(strptime(a.t, format="%Y-%m-%d %H:%M:%S"))){
date.time.flag = 1
corrected.time[i] = NA
}
}
if(date.time.flag){
warning("t without time (HH:MM:SS) input will be set to NA. ")
}
return(corrected.time)
}
CorrectTime(t, lat, long, ZT.min = -6)
CorrectTime = function(t, lat, long, ZT.min = -6){
warning("Please make sure that the input time has the correct time zone. ")
#check if input is POSIXlt
stopifnot("Please input t as POSIXlt format. \n
Time data can be converted to POSIXlt with as.POSIXlt(). Notice that Sys.timezone() will be used if you did not specify correct tz in as.POSIXlt(). " =
sum(class(t)=="POSIXlt")>0)
stopifnot("lat and long should both be vectors" = is.vector(lat)&is.vector(long))
stopifnot("Please make sure that t, lat, and long are of the same lengths" = length(t)==length(lat)&length(t)==length(long))
#calculate sunrise time
day = t$yday
prev_sunrise<- SunRiseTime(day-1, Lat = lat, Long = long)
cur_sunrise <- SunRiseTime(day, Lat = lat, Long = long)
next_sunrise <- SunRiseTime(day+1, Lat = lat, Long = long)
t_chr = as.character(t)
t_UTC = lubridate::with_tz(t, tzone='UTC') #convert time to UTZ
t_UTC_num = t_UTC$hour + t_UTC$min/60
# t_num = t$hour+t$min/60
ZT.max = ZT.min+24
date.time.flag = 0
corrected.time = vector()
for(i in 1:length(t)){
a.t = t[i]
if(t_UTC_num[i]+cur_sunrise$timezone[i]-cur_sunrise$sunrise[i]>=0){
corrected.time[i]<- t_UTC_num[i]+cur_sunrise$timezone[i]-cur_sunrise$sunrise[i]
} else {
corrected.time[i] <- t_UTC_num[i]+prev_sunrise$timezone[i] + (24 - prev_sunrise$sunrise[i])
}
#transform the time into (ZT.min, ZT.max)
ifelse(corrected.time[i]>ZT.max, corrected.time[i]-24,
ifelse(corrected.time[i]<ZT.min, corrected.time[i]+24, corrected.time[i]))
#check if t contains both date and time
if(is.na(strptime(a.t, format="%Y-%m-%d %H:%M:%S"))){
date.time.flag = 1
corrected.time[i] = NA
}
}
if(date.time.flag){
warning("t without time (HH:MM:SS) input will be set to NA. ")
}
return(corrected.time)
}
CorrectTime(t, lat, long, ZT.min = -6)
CorrectTime = function(t, lat, long, ZT.min = -6){
message("Please make sure that the input time has the correct time zone. ")
#check if input is POSIXlt
stopifnot("Please input t as POSIXlt format. \n
Time data can be converted to POSIXlt with as.POSIXlt(). Notice that Sys.timezone() will be used if you did not specify correct tz in as.POSIXlt(). " =
sum(class(t)=="POSIXlt")>0)
stopifnot("lat and long should both be vectors" = is.vector(lat)&is.vector(long))
stopifnot("Please make sure that t, lat, and long are of the same lengths" = length(t)==length(lat)&length(t)==length(long))
#calculate sunrise time
day = t$yday
prev_sunrise<- SunRiseTime(day-1, Lat = lat, Long = long)
cur_sunrise <- SunRiseTime(day, Lat = lat, Long = long)
next_sunrise <- SunRiseTime(day+1, Lat = lat, Long = long)
t_chr = as.character(t)
t_UTC = lubridate::with_tz(t, tzone='UTC') #convert time to UTZ
t_UTC_num = t_UTC$hour + t_UTC$min/60
# t_num = t$hour+t$min/60
ZT.max = ZT.min+24
date.time.flag = 0
corrected.time = vector()
for(i in 1:length(t)){
a.t = t[i]
if(t_UTC_num[i]+cur_sunrise$timezone[i]-cur_sunrise$sunrise[i]>=0){
corrected.time[i]<- t_UTC_num[i]+cur_sunrise$timezone[i]-cur_sunrise$sunrise[i]
} else {
corrected.time[i] <- t_UTC_num[i]+prev_sunrise$timezone[i] + (24 - prev_sunrise$sunrise[i])
}
#transform the time into (ZT.min, ZT.max)
ifelse(corrected.time[i]>ZT.max, corrected.time[i]-24,
ifelse(corrected.time[i]<ZT.min, corrected.time[i]+24, corrected.time[i]))
#check if t contains both date and time
if(is.na(strptime(a.t, format="%Y-%m-%d %H:%M:%S"))){
date.time.flag = 1
corrected.time[i] = NA
}
}
if(date.time.flag){
warning("t without time (HH:MM:SS) input will be set to NA. ")
}
return(corrected.time)
}
CorrectTime(t, lat, long, ZT.min = -6)
as_datetime("13:43:00")
13:43:00
43/60-4/60
library(devtools)
library(roxygen2)
use_gpl_license()
setwd("/Users/xiangningxue/Library/CloudStorage/OneDrive-UniversityofPittsburgh/Research/circadian/ThePipeline/R_package_github/DiffCircaPipeline/DiffCircaPipeline")
uer_r("DCP_getZT")
library(roxygen2)
uer_r("DCP_getZT")
library(devtools)
uer_r("DCP_getZT")
use_r("DCP_getZT")
document()
rm(list = ls())
library(devtools)
library(roxygen2)
load_all()
?DCP_getZT
check()
document()
load_all()
check()
document()
load_all()
check()
devtools::install_github("DiffCircaPipeline/Rpackage")
